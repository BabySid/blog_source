并行编程简述-什么是并行编程
############################

:date: 2016-09-03 21:16
:slug: intro-of-parallel-programming-1
:summary: 并行编程已成为当前提高服务端程序性能的核心技术。这里逐渐介绍下并行编程的基础知识。首先介绍并行编程的概念以及其运行环境的介绍。
:category: 技术
:tags: 并行编程

并行编程需要了解几个概念：

1.  **串行**

这是最基本的程序执行方式，串行程序在整个运行时只有一个调用栈和一个运行时上下文。

2.  **并发（concurrency）**

在多线程技术出现后比较常见的程序执行方式。多线程程序运行时，会有多个运行时上下文以及对应的多个调用栈。逻辑上多个线程同时发生，物理上是由操作系统调度，CPU某一时刻依然只执行一个线程的任务。

3.  **并行（parallelism）**

多核处理器出现后会越来越常见的程序执行方式，物理上多个任务可以同时运行，这个概念介于操作系统和体系架构之间，从操作系统而言，依然是调度多个线程去CPU执行，只不过有了多个CPU/核心，不同线程可以绑定从而完全占用一颗核心，所以从体系架构的角度，同一时刻是有多个任务同时运行；另外一个角度来看，如 `多处理器程序` 、 `多核程序` 都可以认为属于并行程序的范畴。

.. figure:: /images/concurrency_vs_parallelism.jpg
    :width: 330px
    :alt: 图1 并行 vs 并发

    图1 并行 vs 并发

从概念的范围看，并行 < 并发，即并行的程序肯定是并发的，并发的程序不一定是并行的，但是，无论是逻辑上的并发（单处理器）还是物理上的并发（并行，多处理器），所面临的共享数据操作一致性问题是一样的，在很多情况下，多核编程可以近似认为是多线程编程，比如linux对多核的使用就是pthread亲和性绑定。

4.  **并行编程的难点**

并行编程的难点在于同时从宏观和微观两种角度分析问题，并能灵活在两种角度之间切换。 

在之前单处理器的世界里，计算机科学在编译器优化、处理器优化、多线程编程等方面有很深厚的积累，形成了对编程人员而言非常抽象的各种基础库，编程人员无须知道编译器、体系结构、多线程互斥同步等的实现细节。 

进入多处理器后，这个高度抽象的基础库还没有形成，虽然有一些并行库或者开发套件，但抽象程度还不够，依然需要编程人员能理解一定的底层系统结构细节和并行计算模型的能力和局限。
 
5.  **多核体系架构**

根据上文所述，讲到并行编程，不能不谈到多核系统。

- 什么是多核处理器

多内核处理器架构是指：芯片设计工程师在单个处理器中集成两个或多个 “执行内核（即计算引擎）”。多内核处理器可直接插入到单一处理器基座中。但是，操作系统会把它的每个执行内核作为独立的逻辑处理器，为其分配相应的执行资源。要利用多核处理器的运算能力，需要改写操作系统和编译器，广泛使用的vista, vin7，linux 等都能支持多核体系架构。

- 多核发展趋势

首先有一个问题：为什么微处理器要从单核转向多核? 答案是：*功耗问题* 限制了单核无法不断提高性能。

有几个简单的公式可以说明这个问题：

+ 处理器性能 = 主频 * IPC。主频是指每秒时钟周期数，如1GHz表示每秒10亿个时钟周期。IPC则是每个时钟周期可以执行的指令数。处理器微架构的变化可以改变IPC，效率更高的微架构可以提高IPC从而提高处理器的性能。但是，对于同一代的架构，改良架构来提高IPC的幅度是非常有限的，所以在单核处理器时代通过提高处理器的主频来提高性能就成了唯一的手段。
+ 处理器功耗 正比于 电流*电压\ :sup:`2`\*主频， 而“主频正比于电压”，所以处理器功耗 正比 主频\ :sup:`3`\ 。因此，给处理器提高主频不是没有止境的，处理器的功耗和处理器内部的电流、电压的平方和主频成正比，而主频和电压成正比。通过主频提升性能，要面临功耗以3次方的指数增长问题，很快就会触及所谓的“频率墙”（ `frequency wall` ）。所以主频发展到一定程度后，自然转到重点依靠提高IPC来提升性能，提升IPC可以通过提高指令的并行度实现，提高并行度，一是提高微处理器微架构的并行度，二是采用多核架构。
+ 处理器功耗 正比于 电流*电压\ :sup:`2`\*主频， 而“IPC正比于电流”，所以处理器功耗 正比于 IPC。由单核处理器增加到双核处理器，如果主频不变的话，IPC理论上可以提高一倍，功耗理论上也就最多提高一倍，因为功耗的增加是线性的。而实际情况是，双核处理器性能达到单核处理器同等性能的时候，前者的主频可以更低，因此功耗的下降也是指数方(三次方)下降的。反映到产品中就是双核处理器的起跳主频可以比单核处理器更低，性能更好。

由此可见，将来处理器发展的趋势是：为了达到更高的性能，在采用相同微架构的情况下，可以增加处理器的内核数量同时维持较低的主频。这样设计的效果是，更多的并行提高IPC，较低的主频有效地控制了功耗的上升。

虽然商用多核（multicore）和众核（many-core）系统越来越普遍，成本也越来越低，游戏设备、手机等移动设备也具备越来越多的核心，并发和并行越来越成为必要的技术手段，但多核程序的发展依然没有跟上硬件的发展，很多游戏引擎和网络引擎都还是单线程的。原因就是前文提到的多核编程的难度。

- 一个多核处理器的例子

.. figure:: /images/intel_cpu_arch_1.png
    :width: 600px
    :alt: 图2 一个多核处理器的例子

.. figure:: /images/intel_cpu_arch_1_intro1.png
    :width: 600px
    :alt: 图2 一个多核处理器的例子

.. figure:: /images/intel_cpu_arch_1_intro2.png
    :width: 600px
    :alt: 图2 一个多核处理器的例子

    图2 一个多核处理器的例子

这是基于共享缓存的多核体系架构的一个例子，一共有10个核心，不需要深入了解，这张图唯一的目的是介绍一个概念，现代的处理器架构已经比几十年前的冯诺依曼体系复杂多了（各种box），里边稍微值得关注的是Cbox、Bbox，这两个组件是缓存控制器，负责非常核心的功能：`缓存一致性 <http://blackfox1983.github.io/posts/2015/10/11/intro-of-cache-coherency/>`_。最下图则是intel多核体系架构（双路）的缓存示意图，每个core拥有自己的L1和L2缓存，属于一个物理CPU的core共享L3缓存。不同cpu之间通过QPI交互L3数据。每个CPU有自己的内存控制器。对多核编程而言，缓存是非常重要的底层概念。

- 绑核运行

在Linux下，提供了CPU核亲和性机制，进程和线程都可以通过设置亲和性绑定到不同的CPU核上：

.. code-block:: cpp
    :linenos:

    // 进程版本 
    #include <stdio.h>
    #include <sched.h>

    int set_process_to_cpu(int cpu_id) {
        cpu_set_t mask;

        CPU_ZERO(&mask);
        CPU_SET(cpu_id, &mask);

        if (sched_setaffinity(0, sizeof(mask), &mask) < 0) {
            printf("set process affinity failed\n");
            return -1;
        }

        return 0;
        
        /* just for testing getter 
        cpu_set_t get;
        CPU_ZERO(&get);
        if (sched_getaffinity(0, sizeof(get), &get) < 0) {
            printf("get process affinity failed\n");
            return -1;
        }
        */
    }

    // 线程版本
    #include <stdio.h>
    #include <pthread.h>
    #include <sched.h>

    void set_thread_to_cpu(int cpu_id) {
        cpu_set_t mask;    

        CPU_ZERO(&mask);
        CPU_SET(cpu_id, &mask);

        if (pthread_setaffinity_np(pthread_self(), sizeof(mask), &mask) < 0) {
            printf("set thread affinity failed\n");
            return -1;
        }

        return 0;

        /* just for testing getter 
        cpu_set_t get;
        CPU_ZERO(&get);
        if (pthread_getaffinity_np(pthread_self(), sizeof(get), &get) < 0) {
            printf("get thread affinity failed\n");
            return -1;
        }
        */
    }
