动态链接库使用规范
###################

:date: 2015-08-23 14:15
:slug: guide-of-share-lib
:category: 技术
:tags: 动态库
:summary: 动态链接库相对静态库在使用、部署上更为便捷，但是由于使用不当也会造成一些意外。这里介绍一些常见的规范，帮助规避动态库使用上的风险。

动态库（shared library，即lib*.so）由于其部署、二次开发的便捷性，因此较传统的静态库（lib*.a），在一些团队内应用比较广。本文给出开发到部署各个环节相关的说明以及建议，告诉大家如何更好的编写和使用动态库，规避风险。

关于性能：动态库性能一般较静态库性能损耗为1%~30%（如增加的系统调用）。这个和代码以及编译优化参数有关，一般来说，除了在内部逻辑的循环中频繁调用或者轻量级函数实现于动态库中等情况，一般可以忽略。

*但是这里要说明的是，由于动态库带来的问题，一般情况下还是不建议使用动态库。*

1.  **开发**

- 对外接口
    1. 采用 `extern "C"` 的方式声明对外接口。动态链接库多是采用 `dlopen` 方式进行使用，`dlopen` 打开的动态库使用 dlym` 获取接口的时候，如果动态库采用g++编译，并且接口没有使用 `extern "C"` 的方式，获取接口需要 `dlym(handler, "__fooiv")` 这样的方式获取，这在使用和维护上都会带来不便。
    #. 非对外的接口采用static的方式。由于存在 `rdynamic, RTLD_GLOBAL` 等可以把接口提升为全局可见的参数存在，非static的接口也可能会被其他的动态库所用到。

- 版本控制
    动态库和静态库有一个很大的区别就是动态库是需要用来上线部署，不像静态库那样在编译机上就已经被链接进可执行程序中。所以需要有一套机制可以比较方便进行控制。
    1. 对于动态库 xxx.so， 在最后的产出物中需要被命名为 xxx.so.1.0.0.0, 其中1.0.0.0为动态库的4位版本号 这样的好处是动态库在上线的时候一眼就可以看出是否是对应的版本号，另外在一些特殊的条件下也可以并存有多个相同的但版本不同的库. 在使用的时候可以使用一个xxx.so的软连接链到xxx.so.1.0.0.0上，然后程序中使用 dlopen("xxx.so")的方式使用。
    #. 动态链接库本身可以做成可执行的，产出可参考如下：

.. code-block:: shell
    :linenos:

    ld.so: /lib64/ld-linux-x86-64.so.2
    svn: xxx/xxx/xxx
    Brief: test for so
    BuildDate: Aug 22 2015 19:57:55
    Version: 1.0.0.0

不过在一些特殊情况下，比如.so使用了一些全局变量，而这些extern的全局变量是由调用它的二进制程序提供的，这样的.so在编译和被二进制程序载入都是可以正常进行，但是不能独立运行的，这个时候没有全局变量的具体实现，二进制程序不能被载入内存。对于这些情况可以不要求一定要运行，但还是建议要能够被命名为 xxx.so.1.0.0.0。或者单独实现一个mock主进程的 `xxx_version.cpp` （xxx为库名），加载so以show-version。

2.  **编码**

这部分主要是一些二进制兼容方面的建议。

- 二进制与so之间, so与so之间的数据交换尽量采用指针的形式,不要使用具体的结构体或者class。
    1. 不要直接操作结构体, 全部采用接口的形式.当二进制与so所使用结构体不相同的时候,直接操作会出现问题. 
    #. 尽量保证so使用的各种库与二进制使用的各种库版本一致(本质上是保证二进制兼容) 
    #. so注意跟随升级. 二进制程序所依赖的各种版本最好要低于so所用的版本. 最好在二进制升级后(包括依赖库的升级),把所有的.so都重新编译一编. 

事实上如果从这个层面上来说.so本身就失去了很多意义, 这个也是不推荐使用的原因之一。以下为针对上述问题的代码示例：

.. code-block:: cpp
    :linenos:

    //1.0.0版本
    struct demo_t {
        int a;
        int b;
    };

    //后续升级为1.0.1版本
    struct demo_t {
        int a;
        int b;
        int c;
    };

    //对于如下情况
    demo_t *a = so_func_create(); //so_func_create为so提供的对外接口函数，返回一个demo_t指针
    int u = a->c;

当so的版本比二进制的版本要低的时候,这个时候就会出现问题。因为 `so_func_create` 产生的 `demo_t` 是按照升级前的结果给出的，结构体长度只有2个int，没有其中c这个成员, 但是在二进制中是按照存在c来进行访问的，这个时候就造成数据的越界访问。所以二进制依赖的版本不应该高于so所依赖的各种库版本(包括二进制自身)，毕竟我们可以做到高版本对低版本的兼容, 但是无法作到低版本对高版本的兼容。

把上面的例子做一下修改：

.. code-block:: cpp
    :linenos:

    //demo的代码中:
    void demo_todo(demo_t *a) {
          a->c++;
          //.....
    }

    demo_t *a = so_func_create();
    memset(a, sizeof(demo_t), 0);
    demo_todo(a);

即使在so版本比二进制版本要高的情况下，这里也存在问题，在二进制中 `demo_t` 的长度是2个int的长度，但是实际上3个int的长度，这样memset的时候想清零，其实还漏了一个c没有被清零。在后面的操作就出现了问题，这里对于内存元素的操作最好用接口（如 `a->zero_self()` ）进行内部操作，而不是直接暴露数据。

事实上这里存在的一个问题就是so中和二进制中都存在一个函数具体调用哪个的问题,这个在下面的使用章节中说明。

3.  **使用**

这里的使用指的是其它二进制程序使用已有的 `.so` 。

- dlopen的时候不要使用RTLD_GLOBAL
    + RTLD_GLOBAL会导致一个dlopen的动态库符号表全局可见可能会到致其他的动态库在运行时的行为改变
    + 如果遇到一些情况确实需要so之间互相调用，需要注意是否会导致其他问题

+ 对于动态库、静态库混合编译的要求, 建议采用下面两种方案
    + 编译二进制使用 `-rdynamic` (必要的时候采用 `-Wl,--whole-archive -lxxxx -Wl, --no-whole-archive` 把整个库导入)，动态链接库不要链接主程序中有的库,编译时采用与主程序相同版本的库
        - 动态库编译的时候尽量不要去链接基础静态库
        - 如果动态库链接了其他的静态库，在二进制编译的时候可能造成符号表混乱,无论是采用dlopen方式还是采用直接链接的方式，由于动态库和另外的动态库或者 `.a` 中都存在一个相同的符号，这个时候如果存在版本不一致就可能出现一些莫名其妙的错误
        - 另外就是规避一些库中存在全局变量，造成不同的库中使用不同的本地变量但又用了相同的全局变量造成变量逻辑不一致
    + 编译二进制不使用 `-rdynamic` , 动态库链接的使用加上 `-Wl,-Bsymbolic` 参数并且 `.so` 链接所有需要的库，所需要的全局参数通过指针数据在初始化的时候进行传递，比如log, 把东西传到.so，.so里面再open一次(有些32位环境中由于不需要-fPIC参数可能本身不会有问题，但64位下二进制和so中全局变量会用到同一块区域）
        - `-rdynamic` 参数导致二进制程序中的符号变成全局的，如果动态库和二进制程序有同名接口那么会导致动态库调用二进制程序中的同名接口。
        - 如果主程序和动态库都使用了一个库的不同版本，会造成在使用动态库的时候实际调用的是主程序中的版本，而不同版本由于库内部实现的变化可能造成链接的错位从而导致链接的库的使用错误。
        - `-Wl,-Bsymbolic` 参数可以强制把所有的extern的对外全局变量变成在主程序和动态库中都是独立的内存空间,如log库中使用了一些全局变量。
        - 采用 `-rdynamic` 编译后，对于动态库中有和主程序使用的同样的库，要么要与主程序版本保持一致，要么就是编译动态库的时候不链接相同的库(不链接的情况下可能存在对外接口的兼容性问题，需要保证对外接口的一致性)。
        - 共享库和二进制间不要有结构体实体数据的交互(包括inline接口)，全部采用针对指针或者句柄的接口编程

+ 再次载入 `.so` 程序，需要先把原来的handle用 `dlclose` 掉后再重新载入
    - `dlopen` 的时候如果所要的动态库已经被占用，再次 `dlopen` 的时候只是做了引用记数，并没有真的载入 `.so` 哪怕so已经改变。

+ 动态库发布的时候需要把动态链接发布到某个特定目录下，使用软链接将 `xxx.so` 指向 `xxx.so.1.0.0.0` 
    - 虽然我们自己编写的动态链接库多数情况下都是使用 `dlopen` 方式打开使用，但还是有些情况下会出现将动态库像静态库那样链接使用，这时候考虑链接方便需要采用统一的名字。比如 `main` 中使用 `dlopen` 方式打开 `libx.so` 和 `liby.so` , 但 `libx.so` 和 `liby.so` 又需要使用同样的接口而 `main` 又用不到这样的接口，这个时候就可以采用将公用的接口提取出来做为一个动态库，让 `main` 像静态库那样链接使用。

+ 不要随意使用全局变量
    - 由于动态库中全局变量的行为受到编译参数的控制, 全局变量在使用中很容易会造成困惑，比如全局变量两次初始化等问题, (注意: 类中的static成员相当于全局变量，也存在这些问题)。
    - 如果需要使用全局数据，尽量采用单例模式的方式, 声明为 `static` 变量, 通过一个全局的接口（比如 `xxx_get_var` , 这样来拿到需要的指针），内部实现定义的时候是一个NULL, 运行的时候发现为NULL就new一个, 想规避多线程问题可以在载入程序的时候运行, 用一个static class变量的构造和析构专门来分配和释放这个变量或者用gcc的扩展 `__attribute ((constructor))` 和 `__attribute ((destructor)))` 来实现。
    - 如果全局变量间有依赖关系又会涉及到初始化顺序，但在C++中，不同的.cpp中的初始化顺序由链接的时候的顺序来决定，我们很难控制。通过单例的方式可以减少问题。
    - 一些变量的定义可以采用在函数中定义static变量来解决，而不需要对外。
    - 如果有特殊需求，确实需要多个.so都采用同一个全局变量，这里建议由主程序提供全局初始化接口，让多个.so可以在初始化的时候得到对应数据,采用 `get/set` 的接口进行访问。

+ so与主程序之间可以提供一些接口来判断兼容性

4.  **部署**

这里对动态库上线更新提出建议：

+ 确认cp, sync等覆盖方式是否支持更新正在运行的动态库
    1. 需要确认使用中的内核版本是否支持对于已经被载入的动态库进行热切换操作
    #. 所有的切换操作要么保证程序已经停止运行，要么确定已经被dlclose

+ 采用软链接的方式更新和使用动态链接库
    1. 前面提到过，实际生成的动态库名字是带版本号的， 但实际使用的时候可能是采用不带版本号名字(带了版本号就不能随便升级了）, 我们采用 `ln -fs xxx.so.1.1.0.0 xxx.so` 的方式(参数f是强制指向，可以用来修改旧的软连接)来解决这个问题。
    #. 软连接的方式修改使用的库这个过程可以在动态库正在被使用的过程中进行，不需要保证程序停止或者 dlclose。这个过程是安全，但这里软连接的修改不意味着程序使用的动态库版本已经发送变化，其实程序使用的动态库版本还是老版本。
    #. 需要重启程序或者主动 `dlopen` 重新打开才算更新成功。

+ 动态库更新后需要确认更新的是否是我们需要的库版本
    1. 这个过程可以通过 `/usr/sbin/lsof -p $pid` 来确认否载入了我们使用版本的库。

+ `LD_LIBRARY_PATH` 需要加在启动脚本中, 设置在环境中可能会造成其他动态库使用的问题, 不建议使用

5.  **其他**

+ 不要暴露实体在头文件中，采用针对接口或者针对句柄的使用方式
+ .so不要连接实际采用.a
+ 可以考虑把公用部分全部采用.so，然后所以东西都采用和正常的静态库一样的编译方式。缺点是库的版本需要变成op来维护
+ 如果二进制程序长时间不升级，当.so需要使用库的新功能的时候,会很容易导致二进制被迫升级，甚至有些时候会出现其他无关的.so也被迫被升级
+ .so与.so之间的数据交互也不要用实体

6. **总结**

+ so 本质上不能完全解决反向依赖的问题，还是需要有一定的注意事项
+ 在so的一些处理上代价还是比较高昂，一不注意就会存在连锁反应，特别是在持续升级的情况下
+ 建议可以用.a的地方还是尽量用.a，不要为了追求模块化而采用so的方式
+ 在用so的时候注意一下兼容性问题，简单的方式可以先引入版本判断机制，对于so和主程序编译的版本进行强制判断