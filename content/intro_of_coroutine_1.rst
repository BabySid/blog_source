协程-什么是协程
############################

:date: 2018-05-06 14:20
:slug: intro-of-coroutine-1
:summary: 随着服务端开发对于性能以及效率的逐步提升，近几年协程被重新提起并发展。这里逐渐介绍下协程的基础知识，并在后续的篇章中通过实践逐步来研究相关的协程实现。
:category: 技术
:tags: 并行编程；协程

本篇主要介绍协程的基础概念：

1.  **什么是协程**

Wiki: 协程是一种程序组件，是由子例程（过程、函数、例程、方法、子程序）的概念泛化而来的，子例程只有一个入口点且只返回一次，而协程允许多个入口点，可以在指定位置挂起和恢复执行。

据Donald Knuth说：函数就是协程的一种特例。

协程具备两个特点：

- 协程的本地数据在后续调用中始终保持
- 协程在控制离开时暂停执行，当控制再次进入时只能从离开的位置继续执行

协程的历史：

1958年，据Donald Knuth在《计算机程序设计的艺术》说，Melvin Conway在开发COBOL编译器的词法和句法分析器期间创造了协程这个词，并于1963年公开发表。

*这里略提下 Conway定律(196x年)：任意一个软件都反映出制造它的团队的组织结构，这是因为人们会以反映他们组织形式的方式工作。 
换句话说，分散的团队可能用分散的架构生成系统。项目团队的组织结构中的优点和弱点都将不可避免地反映在他们生成的结果系统中。 
这意味着，如果想要努力完成有效的IT架构，那么需要有有效的IT组织结构。*

协程 与 传统组件或技术 的对比：

- 协程 vs 函数
    1. 传统的程序都是依赖多个子程序（函数）的层次调用来完成的，如A调用B、B调用C，C执行完毕返回，B执行完毕返回，最后是A执行完毕返回；这些函数都是通过栈实现的，函数调用总是一个入口，一个栈空间，一次返回，调用顺序是明确的。
    #. 协程的调用与函数不同，协程看上去也是函数，但是在执行过程中，可以显式中断，转而去执行其他函数，在适当的时候再返回来执行；这有点像操作系统的线程，执行过程中可能被挂起，让位于别的线程执行，稍后又从挂起的地方恢复执行。 
    #. 这个过程中，协程与协程之间实际上不是普通“调用者与被调者”的关系，他们之间的关系是对称的。

- 协程 vs 生成器
    1. 生成器（Generator）也是函数的一种泛化，但是比协程有局限性。
    #. 具体的说，两者都可以调用(yield)多次，暂停执行并回到入口初执行。但是他们在控制执行后的处理是不同的，生成器只能将控制权交还给调用生成器的地方，也就是说，生成器主要用于简化迭代器的编写，因此其中的yield不能跳转到特定的函数，只能将值传回到调用者函数中。 

- 协程 vs 递归
    1. 使用协程有点像使用递归，数据控制都切换到了不同的函数中。
    #. 协程会更灵活高效，因为协程是yield而不是return，是resume执行而不是从头开始，因此更容易保存状态。
    #. 递归函数则需要使用共享变量或传输状态参数。此外，递归调用需要新的堆栈而协程则可以复用现有的上下文。

- 协程 vs 回调
    1. 都实现异步通信，但是协程代码可读性、可维护性更好。

下面是来自wiki的协程的示例（注意 整体是单线程运行)：

.. code-block:: py
    :linenos:

    var q := new queue

    coroutine produce
        loop
            while q is not full
                create some new items
                add the items to q
            yield to consume

    coroutine consume
        loop
            while q is not empty
                remove some items from q
                use the items
            yield to produce

2.  **为什么使用协程**

核心问题还是 **并发之痛** 。

真正做到好的并发是很难的，多核编程下，为了提高并发，不可避免的引入线程，在多线程下，又会导致竞争，因此需要需要同步，同步的执行，一定程度上又降低了并发度；
并且在引入线程时，需要考虑内存、os调度成本、物理机器等信息来提高cpu利用率，操作成本非常高；

而常用的优化方法，一般是设置和cpu核数相等的线程，来最大化的降低成本以及内存使用，这里常用的技术就是异步回调、协程；

相比异步回调，协程可以脱颖而出的原因：

- 协程极高的执行效率
    1. 子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。
    #. 不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高。

- 降低编码复杂度。尤其是异步编程（callback hell）。

3.  **协程相关概念**

由于历史上对于协程定义不够精确，遗留下了开放的、关于协程结构的问题。这导致了协程概念的模糊，造成理解上的困扰。这个问题也部分导致了主流语言一直缺乏对协程的支持。
甚至在描述一些本质上属于协程的机制时，如Windows的纤程（Fiber），连协程这个术语都很少被提起。

2004年由Lua的作者Ana Lucia de Moura和Roberto Ierusalimschy所发表的论文Revisiting Coroutines中，才正式对协程进行了分类，论文中依照三个问题区分协程：

- 控制传递（Control-transfer）机制
  
总体上分为：对称（Symmetric）协程和非对称（Asymmetric）协程。

对称协程只提供一种传递操作，用于在协程间直接传递控制；非对称协程（常称为半对称（Semi-symmetric）协程或半（Semi）协程）提供调用和挂起两种操作，挂起时控制返回给调用者。

两者表达力相同并不意味着在易用性上也相同。对称协程会把程序的控制流变得复杂而难以理解和管理，而非对称协程的行为在某种意义上与函数类似，因为控制总是返回给调用者。使用非对称协程写出的程序更加结构化。

简单的说：对称协程需要显式指定将控制权yeild给谁，非对称协程可以隐式的转移控制权给它的调用者。

- 协程是否作为语言的第一类（First-class）对象提供

协程是否作为语言的第一类对象提供对表达力的影响极大。为特定用途而实现的协程，往往把协程对象限制在指定的代码结构中，无法由程序员直接控制。一些语言实现的迭代器和生成器被限制在某个循环内使用，属于受限协程。只有实现为第一类对象的协程可以提供自定义控制结构的能力，而这种能力正是协程强大的表现力所在。

- 协程是否为栈式（Stackful）构造，即是否可以在内部的嵌套调用中挂起

栈式协程允许在内部的嵌套函数中挂起，恢复时从挂起点继续执行。非栈式协程只能在主体部分执行挂起操作，可以用来开发简单的迭代器或生成器，但遇到复杂些的控制结构时，会把问题搞得更加复杂。例如，如果生成器的生成项是通过递归或辅助函数生成的，必须创建出一系列相应层级结构的辅助生成器连续生成项直到到达原始调用点。非栈式协程也不足以实现用户级多任务。

是否为第一类对象以及是否为栈式构造，这两个问题决定了协程的能力。

另外，Revisiting Coroutines一文提出了完全协程的概念，即第一类、栈式的协程对象。随后论证了完全协程的表达力等同于One-shot continuation，Continuation的出现也一定程度上导致了对协程研究的中止，因为普遍认为Continuation的表达力要远超协程。

如今对协程的研究和应用有重新复苏的趋势，主要集中在两个方向。一个是研究它在协作式多任务管理上相对于多线程的优势，目前以程序库和系统资源的方式提供了一些此类协程。
另一个就是用于迭代器和生成器的协程，如Perl、C#、Python等。而Lua基于Revisiting Coroutines的观点，实现了完全非对称协，事实也证明了这种机制在实现一些控制结构时异常方便和强大。